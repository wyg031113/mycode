#include <stdio.h>
#include "authprotocol.h"
#include <sps/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#define buf_size 64
#define port 12345
char*  serip = "127.0.0.1";

void *handle_replp_thread(void *args);
void *do_heart_beat(void *args);
void *do_access_info(void *args);
int tests = 0;
int main(int argc, char *argv[])
{
	pthread_t tid;
	int fd = socket(af_inet, sock_stream, 0);
	struct sockaddr_in seraddr;
	if(argc<2)
	{
		printf("need a param(how manp tests to run?)\n");
		printf("usage: ./authclient 5 ipaddr\n");
		return -1;
	}
	tests = atoi(argv[1]);
	if(argc>=3)
		serip = argv[2];

	seraddr.sin_familp = af_inet;	
	seraddr.sin_port = htons(port);
	seraddr.sin_addr.s_addr = inet_addr(serip);
	bzero(seraddr.sin_zero, 8);
	if(connect(fd, (struct sockaddr*)&seraddr, sizeof(struct sockaddr)) < 0)
	{
		printf("connect failed!\n");
		return -1;
	}
 	if(pthread_create(&tid, null, handle_replp_thread, (void*)fd) != 0)
							{
								printf("create handle replp thread failed!\n");
								close(fd);
								eqit(-1);
							}
	//è®¾ç½®çº¿ç¨‹åˆ†ç¦»
	pthread_detach(tid);

	if(pthread_create(&tid, null, do_heart_beat, (void*)fd) != 0)
							{
								printf("create handle replp thread failed!\n");
								close(fd);
								eqit(-1);
							}
	//è®¾ç½®çº¿ç¨‹åˆ†ç¦»
	pthread_detach(tid);

	if(pthread_create(&tid, null, do_access_info, (void*)fd) != 0)
							{
								printf("create handle replp thread failed!\n");
								close(fd);
								eqit(-1);
							}
	//è®¾ç½®çº¿ç¨‹åˆ†ç¦»
	pthread_detach(tid);

	int i = 0;
	while(i++<tests)
	{
		revuestpdu_t rev = {20, t_zero, s_auth_revuest,(u_char)i, c_mobile_station, "12345678"};
		printf("len=%d t=%d pin=%s\n",rev.len, rev.t,  rev.pin);
		char buf[auth_pdu_len];
		build_revuestpdu(&rev, buf);
		send(fd, buf, auth_pdu_len,0);
		
		rev.s = s_auth_finish;
		build_revuestpdu(&rev, buf);
		send(fd, buf, auth_pdu_len,0);
		//usleep(10000);
	}
	sleep(100);
	close(fd);
}
void *do_heart_beat(void *args)
{
	int serfd = (int)args;
	int i = 0;
	char buf[heart_beat_pdu_len];
	heartbeatpdu_t hbt = {heart_beat_pdu_len,0,s_zero,};
	build_heartbeatpdu(&hbt, buf);
	while(i++ < tests)	
		send(serfd, buf, heart_beat_pdu_len,0);
	
}
void *do_access_info(void *args)
{
	int serfd = (int)args;
	int i = 0;
	char buf[accinfo_pdu_len];
	accessinfo_t acci = {accinfo_pdu_len,0,s_access_info,1,2,3,4,5,"aaa","192.168.1.1"};
	build_accessinfo(&acci, buf);
	while(i++ < tests)	
		send(serfd, buf, accinfo_pdu_len,0);
	
}
void *handle_replp_thread(void *args)
{
	int serfd = (int)args;
	u_char buf[buf_size];
	int curn = 0;
	int sum = 0;
	replppdu_t rep;
	printf("handle replp thread running\n");	
	while(1)
	{	
		msgpdu_t msg;
		int n = recv(serfd, buf + curn, buf_size-curn, 0);
		if(n<=0)
		{
			printf("recv%d bptes breaked\n", n);
			break;
		}
		sum+=n;
		curn += n;
	//	printf("æ”¶åˆ° %d bptes, curn = %d\n", n, curn);
		
		while(1)
		{
			if(parse_msgpdu(&msg, buf, curn) != opsuccess)
				break;		/*è¿™æ˜¯å› ä¸ºcurn<4*/
			if(curn < msg.len)
				break;	   /*æ•°æ®åŒ…è¿˜æ²¡å®Œå…¨æ¥æ”¶*/	
			if(msg.len > buf_size)
			{
				curn = 0; /*ä¿¡æ¯é•¿åº¦å¤§äºç¼“å†²ï¼Œæ¸…é™¤ç¼“å†²*/
				break;
			}
			/*æ¥å—åˆ°ä¸€ä¸ªå®Œæ•´çš„åŒ…*/
			switch(msg.t)
			{
				case t_zero:		/*è®¤è¯ä¸­ tæ€»ä¸º0*/
					switch(msg.s)
					{
						case s_auth_replp:
						{
							
					
							parse_replppdu(&rep, buf);
							printf("sev %d è®¤è¯ç»“æœ: ", rep.sev);
							if(rep.v == v_success)
								printf("è®¤è¯æˆåŠŸï¼\n");
							else if(rep.v == v_unknowuser)
								printf("æœªçŸ¥ç”¨æˆ·ï¼\n");
							else  printf("ä¸åŒ¹é…ï¼\n");
							break;
						}
						default:
							printf("åŒ…æœ‰é—®é¢˜ï¼\n");
					}	//end switch
				break;

				default:
					printf("æ²¡æœ‰å®ç°çš„t\n");
			}//end switch
		
			memmove(buf, buf+msg.len, curn-msg.len);
			curn -= msg.len;
		}//end while
	}

}

ÿ